<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Hexo
    </title>
    <meta name="description" content= This is Dajunnnnn's blog >
    <meta name="keywords" content= Blog,Hexo,Theme,Dajunnnnnn >
    
<link rel="stylesheet" href="/Dajunnnnnn.github.io/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/Dajunnnnnn.github.io/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/Dajunnnnnn.github.io/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            System Knowledge.md
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>OS定义：控制软硬件、调度和资源分配、提供接口和环境（命令接口和程序接口、库函数和系统调用）</li>
<li>OS特征：并发、共享、虚拟、保护（前俩最基本、并发与并行的区别）</li>
<li>甘特图：纵程序、横时间，画资源</li>
<li>OS发展：多道批处理、分时、实时</li>
<li>OS运行环境：用户态与核心态、中断和异常、中断处理过程、访管指令（陷入指令）</li>
<li>通道和中断的作用：实现I/O与CPU并行</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h3><ol>
<li>进程=PCB+程序段+数据段（所有系统调用都操作 PCB）；线程=TCB+堆栈+寄存器</li>
<li>运行态到阻塞态：是一种特殊的、由用户态调用操作系统内核过程的形式（主动）；阻塞态到就绪态：被动行为</li>
<li>进程作为CPU以外的sys资源分配的基本单位，线程作为处理机调度的基本单位，共享进程资源</li>
<li>线程实现：用户级线程、内核级线程；多线程模型：多对一、一对一、多对多</li>
<li>父进程创建子进程与主程序调用子程序（并行/串行）；多线程与多任务（针对进程/针对OS）<br><img src="C:\Users\10640\AppData\Local\Temp\1628124979332.png" alt="1628124979332"></li>
</ol>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul>
<li>共享存储：生-消模型、互斥访问共享存储区、“布袋”</li>
<li>消息传递：以Message为基本单位，使用OS发送、接受原语，直接通信（邮差）、间接通信（邮箱）</li>
<li>管道通信：半双工通信（单向）、固定大小、数据一次性、读空才写写满才读、pipe文件</li>
</ul>
<h3 id="软硬件实现临界互斥的方法"><a href="#软硬件实现临界互斥的方法" class="headerlink" title="软硬件实现临界互斥的方法"></a>软硬件实现临界互斥的方法</h3><ul>
<li>单标志法：turn、违空闲让进</li>
<li>双标志先检查：flag[2]、违忙则等待</li>
<li>双标志后检查：flag[2]、违有限等待</li>
<li>皮特森算法：1+3、违让权等待</li>
<li>中断屏蔽、TSL（test and set）、swap</li>
</ul>
<h3 id="PV操作（进程同步）阻塞-上锁"><a href="#PV操作（进程同步）阻塞-上锁" class="headerlink" title="PV操作（进程同步）阻塞+上锁"></a>PV操作（进程同步）阻塞+上锁</h3><ul>
<li>基础知识<br>同步：某个行为要用到某种资源在前面P一下；某个行为能产生某种资源在后面V一下（协调工作次序）<br>互斥：P、V操作夹紧使用互斥资源的行为，尽量保证最少的代码（互斥访问临界资源）<br>P、V：P在信号量有数时才减1，否则阻塞<br>临界资源：一次只允许一个进程访问的可共享的资源（不能修改的代码不属于临界资源）</li>
<li>前驱关系：前V后P</li>
<li>生产者-消费者：两对同步or一对同步，当有全局变量时如修改则要PV一下</li>
<li>读者-写者：可多个进程同时访问，用count计数，第一个P一下，最后一个V一下，在访问count时要互斥访问，属于共享资源。（读写公平多用一组pv同步）</li>
<li>哲学家进餐：需要同时取多个资源，为防止死锁，取前P全取完V</li>
<li>吸烟者问题：一个生产者多个消费者，注意怎么唤醒、怎么阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line">produce ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        produce an item in nextp;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        Add nextp to buffet;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        remove an item from buffet;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        consume the item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semaphore plate = <span class="number">1</span>,apple = <span class="number">0</span>,orange = <span class="number">0</span>;</span><br><span class="line">Dad()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;    </span><br><span class="line">        P(plate);</span><br><span class="line">        V(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Mom()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">         P(plate);</span><br><span class="line">         V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Son()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        P(plate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Daughter()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple);</span><br><span class="line">        P(plate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span><span class="comment">//count互斥</span></span><br><span class="line">semaphore rw = <span class="number">1</span><span class="comment">//读写互斥</span></span><br><span class="line">Writer()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//P(w);写进程优先 </span></span><br><span class="line">        P(rw);</span><br><span class="line">        Writing;</span><br><span class="line">        V(rw);</span><br><span class="line">        <span class="comment">//V(w);写进程优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Reader ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//P(w);</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            P(rw);</span><br><span class="line">        count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">//V(w);不加到最后，加到这就足够了</span></span><br><span class="line">        Reading;</span><br><span class="line">        P(mutex);</span><br><span class="line">        count—-;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            V(rw);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P(mutex);<span class="comment">//互斥取筷子,一次取完两根</span></span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>];</span><br><span class="line">        V(mutex);</span><br><span class="line">        Eat;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>];</span><br><span class="line">        Think;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> random;</span><br><span class="line">semaphore offer1 = <span class="number">0</span>,offer2 = <span class="number">0</span>,offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//表示抽烟是否完成，是一种前驱关系，同步关系，完成后才能放新的</span></span><br><span class="line">Process p1()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        random=任意一个整数随机数;</span><br><span class="line">        random=random%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">            V(offer1);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">            V(offer2);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            V(offer3);</span><br><span class="line">        任意两种材料放在桌子上；</span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Process pi()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(offeri);</span><br><span class="line">        取走；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>,chairs = n;</span><br><span class="line">semaphore customers = <span class="number">0</span>,barbers = <span class="number">0</span>,mutex = <span class="number">1</span>;</span><br><span class="line">barber ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(customers);</span><br><span class="line">        P(mutex);</span><br><span class="line">        waiting = waiting - <span class="number">1</span>;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(barbers);</span><br><span class="line">        Cut_hair();</span><br><span class="line">&#125;</span><br><span class="line">customer ()&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; chairs)&#123;</span><br><span class="line">        waiting = waiting + <span class="number">1</span>;</span><br><span class="line">        V(customers);</span><br><span class="line">        V(mutex);</span><br><span class="line">        P(barbers);</span><br><span class="line">        Get_haircut();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        V(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul>
<li>高级调度（作业-&gt;进程）、中级调度（外存&lt;-&gt;内存）、低级调度（三态转化）</li>
<li>不能调度（处理中断、临界区、屏蔽中断）；剥夺与非剥夺调度（早期批处理）【在进程处于临界区时，只要不破坏临界区资源使用规则就不影响处理机调度】</li>
<li>评估：CPU利用率（忙碌时间/总时间）、系统吞吐量（完成作业数/总时间）、平均周转时间（提交到完成/n=（等待+执行）/n）、带权周转时间（作业周转时间/实际运行时间，越小越好必然大于1）、等待时间（等处理机状态）、响应时间（提交请求到首次响应）</li>
<li>先来先服务（FCFS）：选最早</li>
<li>短作业/进程优先（SJF/SPF）：选最短（平均等待时间、平均周转时间最少）</li>
<li>优先级调度：选优先级最高（净：sys&gt;users、交互&gt;非交互、I/O&gt;CPU）</li>
<li>高相应比优先（HRRN）：响应比最高<br>（等待时间+需服务时间）/需服务时间</li>
<li>时间片轮转（RR）：分时OS、绝对可抢占</li>
<li>多级反馈队列：1+3+5、“UNIX”、优先级高到低、时间片小到大（上无才执行下）</li>
</ul>
<h3 id="死锁（独占资源分配不当）"><a href="#死锁（独占资源分配不当）" class="headerlink" title="死锁（独占资源分配不当）"></a>死锁（独占资源分配不当）</h3><ul>
<li>死锁定义：多个进程因竞争资源而造成的一种僵局（互相等待）若无外力作用，这些进程都将无法向前推进</li>
<li>产生原因：竞争资源、进程推进非法</li>
<li>预防死锁：破坏互斥（资源共享使用）、破坏不剥夺、破坏请求和保持（预先静态分配）、破坏循环等待（顺序资源分配）（必要条件）</li>
<li>避免死锁：安全状态（不一定是死锁状态）、银行家算法（必须知道将来的资源请求）、安全性算法</li>
<li>检测死锁：利用死锁定理化简资源分配图（圆圈代表进程，框代表一类资源，一个圆代表一个该类资源，进程到资源为请求边，资源到进程为分配边）把圈都变成孤点</li>
<li>解除死锁：资源剥夺、撤销进程、进程回退</li>
</ul>
<h3 id="银行家算法（死锁检测）"><a href="#银行家算法（死锁检测）" class="headerlink" title="银行家算法（死锁检测）"></a>银行家算法（死锁检测）</h3><ul>
<li>Max、Allocation、Need</li>
<li>Work、Need、Allocation、W+A（分配一个写一行，一行一行写）</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="程序的编译、链接和装入"><a href="#程序的编译、链接和装入" class="headerlink" title="程序的编译、链接和装入"></a>程序的编译、链接和装入</h3><ul>
<li>编译成若干0-n，链接成一个0-m，装入将逻辑地址转换为物理地址（地址重定位）</li>
<li>静态链接、装入时动态链接、运行时动态链接</li>
<li>绝对装入、可重定位装入、运行时动态装入（动态重定位、只装入一部分可以提供比内存大的地址空间）</li>
</ul>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><ul>
<li>上下限寄存器</li>
<li>重定位寄存器和界地址寄存器：逻辑&lt;界地址，物理=逻辑+重定位</li>
</ul>
<h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><ul>
<li>覆盖：一个程序内，用虚拟内存替代</li>
<li>交换：中级调度，现在还在用</li>
</ul>
<h3 id="内存分配（连续分配方式）"><a href="#内存分配（连续分配方式）" class="headerlink" title="内存分配（连续分配方式）"></a>内存分配（连续分配方式）</h3><ul>
<li>单一连续分配：单用户单任务OS、有内无外</li>
<li>固定分区分配：一个分区一到作业、分区说明表（始址+大小+状态）、有内无外</li>
<li>动态分区分配：（紧凑）（有外无内）</li>
<li>首次适应：(First Fit)地址递增，第一个能装进去的（最好、最快）</li>
<li>最佳适应：(Best Fit)容量递增，有很多外部碎片！！！</li>
<li>最坏适应：(Worst Fit)容量递减，很快无大连续快</li>
<li>邻近适应：(Next Fit)又称循环首次适应，从上一次结束开始不从头找</li>
</ul>
<h3 id="内存分配（非连续分配方式）"><a href="#内存分配（非连续分配方式）" class="headerlink" title="内存分配（非连续分配方式）"></a>内存分配（非连续分配方式）</h3><ul>
<li>存储密度低于连续分配方式，但少了很多页内碎片</li>
<li>运行时是否把所有作业都装入内存（基本分页/请求分页）</li>
<li>地址结构决定了虚拟内存的寻址空间有多大</li>
</ul>
<h3 id="基本分页存储管理方式（透明）（有内部碎片）"><a href="#基本分页存储管理方式（透明）（有内部碎片）" class="headerlink" title="基本分页存储管理方式（透明）（有内部碎片）"></a>基本分页存储管理方式（透明）（有内部碎片）</h3><ul>
<li>进程（页）-&gt;内存（页框）-&gt;外存（块）</li>
<li>页表（页号+物理块号）-&gt;页面-&gt;地址结构（页号+页内偏移量）</li>
<li>地址变换机构+逻辑地址到物理地址转换过程（页表寄存器=页表始址+页表长度）</li>
<li>快表（高速缓冲存储器，非内存）：少访问一次内存，有一次访问数据</li>
<li>两级页表：减少了内存占用空间，只有一个顶级页表</li>
</ul>
<h3 id="基本分段存储管理方式（不透明）（有外部碎片）"><a href="#基本分段存储管理方式（不透明）（有外部碎片）" class="headerlink" title="基本分段存储管理方式（不透明）（有外部碎片）"></a>基本分段存储管理方式（不透明）（有外部碎片）</h3><ul>
<li>段内连续，段间不连续，地址空间是二维的（段的始址+段内偏移量）</li>
<li>段表项：段号+段长+本段在主存的始址</li>
<li>段表内位置要查一次，找到段的位置，段内偏移量又要查一次，真正的物理地址（段表寄存器=段表始址+段表长度）</li>
</ul>
<h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><ul>
<li>段号+页号+页内偏移量</li>
<li>一个进程一个段表，一个分段一个页表</li>
<li>段表项=段号+页表长度+页表始址；页表项=页号+块号；段表寄存器=段表长度+段表始址</li>
<li>首先通过段表查到页表始址-&gt;通过页表查到页帧号-&gt;物理地址（段号查段表、页号查页表、最后加偏移量）</li>
<li>二维的原因：与页式管理不同，段式管理不能通过给出一个整数便确定对应的物理地址，因为每段的长度是不固定的，无法通过整数除法得出段号，无法通过取余得出段内偏移，所以段号和段内偏移一定要显示给出，因此分段管理的地址空间是二维的。</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>页表项的大小有页表数量决定，2²⁰个页表需要20/8上取整，及3B，但一般都取4B（1B有8位）前面的操作是为了同时将多个进程保存在内存中，后面的操作是为了让一个进程的尽量少的一部分装入内存</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li>基于局部性原理（时间、空间）：容量小于等于内外存之和，也小于等于计算机地址位数能容纳的最大容量</li>
<li>实现方式：请求分页、请求分段、请求段页式</li>
<li>需支持：内存+外存、页表机制、中断机构、地址变换机构</li>
<li>页表机制：页号、物理块号、状态位P、访问字段A（访问次数）、修改位M、外存地址</li>
<li>中断机构：指令执行期间处理中断（内中断）、一条指令执行期间可产生多次缺页中断</li>
<li>地址变换机构：检索快表、（未找到）去内存中找页表、（在内存）根据物理地址访问内存、（没在内存）缺页中断去外存找</li>
<li>虚拟内存&lt;=内存容量和外存容量之和&amp;&amp;虚拟内存&lt;=计算机地址结构所能容纳的最大容量</li>
</ul>
<h3 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h3><ul>
<li>OPT：向后找（无法实现）</li>
<li>FIFO：队列实现（Belady异常【3210 3243 2104】、性能差）</li>
<li>LRU：（最近最久未用）向前看（性能好、堆栈开销大）</li>
<li>CLOCK：（NRU：Not Recently Used，最近未用）首次装入内存该帧使用位置为1；当要替换时扫描缓冲区，如果是1则改成0，如果是0则换出并指向下一帧。（当某一帧被替换时，指针被设置成指向缓冲区的下一帧）</li>
<li>改进CLOCK：（使用位，修改位）扫描第一次：找（0，0）不做修改；扫描第二次：找（0，1）并且将（1，x）-&gt;（0，x），再次从头开始找（0，0）。首选没变化的页面00-&gt;01-&gt;10-&gt;11（换完后将指针后移）</li>
<li>发生缺页的次数！=页面置换的次数</li>
</ul>
<h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><ul>
<li>驻留集大小：（分配几个物理页框）固定分配局部置换（自给自足）、可变分配全局置换（要就给）、可变分配局部置换（非常想要才给，否则自给自足，多了还往回拿）</li>
<li>何时、何处调入页面：预调页策略（一次调入若干相邻，首次调时用）、请求调页策略；文件区/对换区：对换区大则都在对换区换，对换区不大只在对换区换修改过的；UNIX：未运行过的在文件区，运行过的在对换区</li>
<li>抖动：一个进程在换页上用的时间多于执行时间</li>
<li>工作集：某段时间间隔内，进程要访问的页面集合（不重复），分配的物理块数要大于工作集的大小</li>
<li>工作集模型：工作集内的页面调入驻留集，工作集外的页面调出驻留集，空闲块多则调入进程，空闲块少则暂停进程</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>以磁盘为载体存储在计算机上的信息集合，文件=数据+FCB+访问权限</li>
<li>系统运行时，资源分配和调度的基本单位：进程；用户输入、输出中，以文件为基本单位</li>
<li>文件结构：数据项&lt;记录&lt;文件（记录式文件、流式文件）</li>
<li>文件的唯一标签：标识符（名字有重名）</li>
</ul>
<h3 id="文件相关操作"><a href="#文件相关操作" class="headerlink" title="文件相关操作"></a>文件相关操作</h3><ul>
<li>创建（找到空间+创建目录条目）、读、写、截断（删除内容不删除文件）、文件重定位（寻址）、删除（删文件）</li>
<li>打开与关闭：打开文件表（省略搜索环节）、打开计数器（打开文件的进程数）、在open调用完成后，OS对该文件的任何操作都不再需要文件名，而只需要open调用返回的指针、close后：写回外存、释放内存、删除文件打开条目、释放FCB</li>
</ul>
<h3 id="文件逻辑结构（用户角度）"><a href="#文件逻辑结构（用户角度）" class="headerlink" title="文件逻辑结构（用户角度）"></a>文件逻辑结构（用户角度）</h3><ul>
<li>无结构文件（流式文件）</li>
<li>有结构文件（记录式文件）：顺序文件（串结构、顺序结构）、索引文件（索引表、记录变长记录文件）、索引顺序文件（每组第一条记录为索引项）、直接文件或散列文件</li>
<li>有结构文件是为了方便查找</li>
</ul>
<h3 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h3><ul>
<li>文件控制块（FCB），一个FCB就是一个文件目录项，FCB必须有序存放，FCB有序集合即为目录</li>
<li>索引节点：=FCB-精简版目录项，存放在磁盘上，文件被打开时复制到内存中的索引节点</li>
<li>目录结构：单级目录、两级目录（主文件目录（user1、user2…）+用户文件目录）、多级目录（树形目录、绝对路径、相对路径、分隔符/、当前工作目录.）、无环图目录（增加一些指向同一节点的有向边）</li>
</ul>
<h3 id="文件共享与保护（目录-gt-文件）"><a href="#文件共享与保护（目录-gt-文件）" class="headerlink" title="文件共享与保护（目录-&gt;文件）"></a>文件共享与保护（目录-&gt;文件）</h3><ul>
<li>硬链接：设置指针指向索引节点的共享方式（链接计数count）原count+1，一个文件的count统一变化</li>
<li>软连接：基于符号链实现文件共享（与共享文件同名的LINK型文件，只包含共享文件的路径名，类似于快捷方式，指针指向快捷方式）直接复制原count，删文件count不变</li>
<li>文件保护：口令保护、加密保护、访问控制（访问控制表ACL：用户名+读+写+执行）<pre><code>A        B        C
</code></pre>
user1 r        rw         w<br>user2 e         -           -</li>
</ul>
<h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3><ul>
<li>用户调用接口：根据系统调用，转入相应的模块</li>
<li>文件目录结构：根据文件路径找到相应FCB或索引节点、目录项</li>
<li>存取控制验证模块：权限比较，文件保护相关功能</li>
<li>逻辑文件系统与文件信息缓冲区：把用户读写的逻辑记录转换成逻辑块号</li>
<li>物理文件系统：将逻辑块号转成物理块号</li>
<li>其它：辅助分配模块、设备管理模块</li>
</ul>
<h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><ul>
<li>线形列表：线性查找，文件名+数据块指针，查找慢</li>
<li>哈希表：散列查找，根据文件名得到hash值，hash表长固定且hash函数对表长有依赖</li>
</ul>
<h3 id="文件物理结构（文件实现）"><a href="#文件物理结构（文件实现）" class="headerlink" title="文件物理结构（文件实现）"></a>文件物理结构（文件实现）</h3><h3 id="文件分配方式（非空闲块）"><a href="#文件分配方式（非空闲块）" class="headerlink" title="文件分配方式（非空闲块）"></a>文件分配方式（非空闲块）</h3><ul>
<li>连续：目录项（文件名+起始块号+长度）寻道数和寻道时间最小</li>
<li>链接（串联）：文件分配表（显）（目录项：文件名+起始块号；FAT表：盘块号+下一盘块指针）、盘块内指针（隐）（文件名+起始块指针+结尾块指针）【注】FAT表启动时就会被读入内存，因此查找FAT表的过程是在内存中进行的。</li>
<li>索引：（支持直接访问）当文件过大时有三种分配方式：链接（一个连一个）、多层（一个连n个）、混合索引（一级索引、二级索引…）</li>
</ul>
<h3 id="存储空间管理（空闲块）"><a href="#存储空间管理（空闲块）" class="headerlink" title="存储空间管理（空闲块）"></a>存储空间管理（空闲块）</h3><ul>
<li>空闲表：类似于内存的动态分配，第一个空闲盘块号+空闲盘块数</li>
<li>空闲链表：空闲盘块链/空闲盘区链</li>
<li>位示图：0空闲、1已分配（找0，算物理地址，改1，插入数据）</li>
<li>成组链接：见下</li>
</ul>
<h3 id="成组链接"><a href="#成组链接" class="headerlink" title="成组链接"></a>成组链接</h3><ul>
<li>超级块（下一组空闲盘块数+若干空闲块号）复制到超级快，或从超级快拿走</li>
<li>第一个空闲块指向下一组的类似超级块，其余指向空闲块，倒数第二个分组超级快的第一个空闲块数为-1</li>
<li>从下往上分配块，从上往下归还块，最后一个块被占用不为空闲，可用块数=总块数-1</li>
</ul>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul>
<li>地址：柱面号·盘面号·扇区号（或块号）【根据柱面移动磁头找到磁道、根据盘面决定启动哪个磁头，根据扇区号旋转盘面找到数据块】</li>
<li>磁道为同心圆，存储能力受限于最内道的最大记录密度</li>
<li>一次磁盘读写操作的时间：寻道时间（移道时间*n+启动磁臂时间）+延迟时间（磁头定位到扇区的时间）+传输时间（从磁盘读出或向磁盘写入的时间）</li>
<li>磁盘初始化：低级格式化（物理分区，分扇区）、逻辑格式化（创建文件系统）</li>
<li>引导块：初始化程序（自举程序），在ROM中（只读存储器，只能读不能写）</li>
<li>数据传输速率：数据传输量（KB）/所用时间（s）【注】表示存储容量、文件大小时K等于1024，表示传输速率时K等于1000，所以得*1024/1000进行转换</li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul>
<li>FCFS：根据进程请求访问磁盘的先后顺序，公平</li>
<li>SSTF：找离当前最接近的（饥饿）</li>
<li>SCAN（LOOK）：（又称电梯调度算法）两侧都扫描，走到头往回走，到头or不到头</li>
<li>C-SCAN（C-LOOK）：只能单侧，访问到头快速返回至始端，解决两端不平衡的问题<br>【注】look不走到头，scan走到头；带C只能一个方向扫描，不带C扫描完回头反向扫描</li>
</ul>
<h2 id="输入输出管理（I-O）"><a href="#输入输出管理（I-O）" class="headerlink" title="输入输出管理（I/O）"></a>输入输出管理（I/O）</h2><h3 id="I-O控制方式（外设与内存间传输方式）（城中D道）"><a href="#I-O控制方式（外设与内存间传输方式）（城中D道）" class="headerlink" title="I/O控制方式（外设与内存间传输方式）（城中D道）"></a>I/O控制方式（外设与内存间传输方式）（城中D道）</h3><ul>
<li>程序直接控制：对读入的每个字进行循环检查，CPU与I/O串行，CPU利用率极低</li>
<li>中断驱动方式：读一个字中断一次，I/O操作开始前和完成后需要CPU</li>
<li>DMA方式（直接存储器存储）：（读一个数据块中断一次）在I/O设备和内存之间开辟直接的数据通路，传连续的数据块到内存，全传完才需CPU干预（命令寄存器、内存地址寄存器、数据寄存器、数据计数器）</li>
<li>通道方式：弱鸡版的CPU（硬件），第一组数据块中断一次，通过执行CPU发来的通道程序（内存中的任务清单）完成对应I/O任务</li>
<li>助记：每隔一段时间看看衣服好没；完成一件衣服打电话告知；雇一位秘书，交代好一切，每做100件报告一次；秘书决定衣服放在哪，什么时候报告。（一个DMA秘书只能负责一位裁缝，一个通道秘书可与多个裁缝沟通）</li>
</ul>
<h3 id="I-O子系统层次结构"><a href="#I-O子系统层次结构" class="headerlink" title="I/O子系统层次结构"></a>I/O子系统层次结构</h3><ul>
<li>用户层I/O软件：必须通过一组系统调用来获取操作系统服务（各种库函数）</li>
<li>设备独立性软件：（又称系统调用处理层、设备无关性）为了实现设备独立性引入：逻辑设备&amp;物理设备、设备独立性软件。功能：执行所有设备的公有操作（维护逻辑设备表：将逻辑设备名映射为物理设备名），向用户层提供统一的接口（例如：read、write命令）</li>
<li>设备驱动程序：一类设备一个驱动程序</li>
<li>中断处理程序：用于保存中断进程的CPU环境，转入相应中断进程（放在底层的原因：由于中断处理与硬件紧密相关，对用户而言应尽量屏蔽，因此放在OS的底层，其它部分尽可能少的与之联系）</li>
<li>硬件：I/O设备=机械部件+电子部件（适配器）</li>
</ul>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul>
<li>接受和识别CPU或通道发来的命令（控制寄存器）</li>
<li>实现数据交换（数据寄存器）</li>
<li>发现和记录设备及自身的状态信息（状态寄存器）</li>
<li>设备地址识别（为了区分各个寄存器）</li>
</ul>
<h3 id="I-O子系统概述"><a href="#I-O子系统概述" class="headerlink" title="I/O子系统概述"></a>I/O子系统概述</h3><ul>
<li>I/O调度：确定一个好的顺序来使进程之间公平的共享设备访问，减少I/O完成所需要的平均等待时间（磁盘调度算法）</li>
<li>高速缓冲与缓冲区：逻辑上属于磁盘，物理上则是驻留在内存中的盘块。缓冲区非空不能冲入数据，缓冲区充满才能读。</li>
</ul>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>技巧：假设一种初始状态，然后计算下一次到达相同状态的所需时间，就是处理一块数据所需时间</p>
<ul>
<li>单缓冲：工作区满、缓冲区是空的</li>
<li>双缓冲：工作区空、一个缓冲区满、另一个缓冲区是空的</li>
<li>循环缓冲：类似于循环队列</li>
<li>缓冲池：输入缓冲队列、输出缓冲队列、收容输入、提取输入、收容输出、提取输出</li>
<li>设备分配与回收：设备控制表（一个设备及其属性）、控制器控制表（控制器：解析上层命令，与设备控制表一一对应）、通道控制表（一个通道管多个控制器，为了与内存交换数据）、系统设备表（一个系统一张，标示所有物理设备）</li>
<li>设备分配策略：静态（一次性）、动态（系统调用向系统提出请求）、安全分配方式（发出I/O请求就进入阻塞态）、不安全分配方式</li>
</ul>
<h3 id="SPOOLing技术"><a href="#SPOOLing技术" class="headerlink" title="SPOOLing技术"></a>SPOOLing技术</h3><ul>
<li>用输入输出进程模拟外围控制机，来进行输入输出操作</li>
<li>输入输出井在磁盘中、输入输出缓冲区在内存中<br>-输入输出先放到磁盘输入输出井中，待I/O设备空闲再输入输出</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>现代操作系统的两个基本特征是共享性和并发性</li>
<li>作业由程序、数据、作业说明书组成</li>
<li>文件按组织形式分类：普通、目录、特殊</li>
<li>文件包括两部分：文件和文件说明</li>
<li>CPU输出数据的速度远远高于打印机的打印速度，为了缓解这一矛盾，可采用??缓冲技术??</li>
<li>OS为用户提供了两种接口：操作级接口（命令接口）：为用户提供各种命令；程序级接口（系统调用）：为用户程序一级提供有关服务</li>
<li>资源有序分配法破坏了产生死锁的必要条件中的环路等待</li>
<li>临界资源是一次只能为一个进程使用的资源；临界区是指访问临界资源的那段代码</li>
<li>在单个CPU系统中，CPU和线程是并行操作的</li>
<li>访问磁盘时间由三部分组成：寻道时间+延迟时间+传输时间</li>
<li>在处理机调度中，内外存调度实际上是进程的挂起与激活</li>
</ul>
<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递。（RFC）</li>
</ul>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><ul>
<li><p>应用层(Application Layer)<br>协议：FTP (文件传输)，SMTP (邮件)，HTTP (万维网)，DNS</p>
</li>
<li><p>传输层(Transport Layer)（报文）<br>功能：可靠传输/不可靠传输，差错处理，流量控制，复用分用<br>协议：TCP（报文段）、UDP（用户数据报）</p>
</li>
<li><p>网络层(Network Layer)（分组/数据报）<br>功能：路由选择（最佳路径），流量控制，差错控制，拥塞控制</p>
<p>协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p>
</li>
<li><p>数据链路层(Data Link Layer)（帧）<br>功能：成帧（定义帧的开始和结束），差错控制（帧错+位错），流量控制，访问接入控制（控制对信道的访问），物理寻址<br>协议：SDLC、HDLC、PPP、STP、Ethernet</p>
</li>
<li><p>物理层(physical Layer)<br>功能：定义接口特性，定义传输模式（单工、半双工、双工），定义传输速率，比特同步，比特编码<br>协议：Rj45、802.3<br>设备：中继器：转发器、集线器（Hub）：多端口中继器，双绞线、同轴电缆、光纤、无线传输介质。</p>
</li>
</ul>
<h2 id="2-网络层协议"><a href="#2-网络层协议" class="headerlink" title="2.网络层协议"></a>2.网络层协议</h2><h3 id="2-1ARP协议"><a href="#2-1ARP协议" class="headerlink" title="2.1ARP协议"></a>2.1ARP协议</h3><h3 id="2-2IP协议"><a href="#2-2IP协议" class="headerlink" title="2.2IP协议"></a>2.2IP协议</h3><h3 id="2-3ICMP协议"><a href="#2-3ICMP协议" class="headerlink" title="2.3ICMP协议"></a>2.3ICMP协议</h3><h2 id="4-传输层协议"><a href="#4-传输层协议" class="headerlink" title="4.传输层协议"></a>4.传输层协议</h2><h3 id="4-3TCP协议"><a href="#4-3TCP协议" class="headerlink" title="4.3TCP协议"></a>4.3TCP协议</h3><h3 id="4-4UDP协议"><a href="#4-4UDP协议" class="headerlink" title="4.4UDP协议"></a>4.4UDP协议</h3><h2 id="5-应用层协议"><a href="#5-应用层协议" class="headerlink" title="5.应用层协议"></a>5.应用层协议</h2><h3 id="5-1DNS"><a href="#5-1DNS" class="headerlink" title="5.1DNS"></a>5.1DNS</h3><h3 id="5-2HTTP"><a href="#5-2HTTP" class="headerlink" title="5.2HTTP"></a>5.2HTTP</h3><blockquote>
<p>超文本传输协议（Hyper Text Transfer Protocol）是一个简单的请求-响应协议，它通常运行在Tcp之上。 </p>
</blockquote>
<h4 id="5-2-1概述"><a href="#5-2-1概述" class="headerlink" title="5.2.1概述"></a>5.2.1概述</h4><ul>
<li>HTTP/1.0:客户端与web服务器连接后，只能获得一个web资源，然后就断开连接</li>
<li>HTTP/1.1:客户端与web连接后可以获得多个web资源</li>
</ul>
<h3 id="5-2-2Http请求"><a href="#5-2-2Http请求" class="headerlink" title="5.2.2Http请求"></a>5.2.2Http请求</h3><ul>
<li>请求头</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Request URL: https:<span class="comment">//www.baidu.com/</span></span><br><span class="line">Request Method: GET  <span class="comment">//Get:一次请求参数少限制大小，会在浏览器URL地址栏显示数据内容，不安全但高效；</span></span><br><span class="line">                <span class="comment">//Post：一次请求参数多不限制大小，不会在浏览器URL地址栏显示数据内容，安全但不高效；</span></span><br><span class="line">Status Code: <span class="number">200</span> OK</span><br><span class="line">Remote Address: <span class="number">182.61</span><span class="number">.200</span><span class="number">.7</span>:<span class="number">443</span></span><br><span class="line">Referrer Policy: origin-when-cross-origin</span><br></pre></td></tr></table></figure>

<ul>
<li>消息头</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept:    <span class="comment">//告诉浏览器他所支持的数据类型</span></span><br><span class="line">Accept-Encoding: gzip, deflate, br <span class="comment">//GBK,UTF-8,GB2312,ISO-88591</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.9</span> <span class="comment">//中文</span></span><br><span class="line">Cache-Control: max-age=<span class="number">0</span> <span class="comment">//缓存控制</span></span><br><span class="line">Connection: keep-alive <span class="comment">//告诉浏览器请求结束是断开还是保持连接</span></span><br><span class="line">HOST:<span class="comment">//主机</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-3Http响应"><a href="#5-2-3Http响应" class="headerlink" title="5.2.3Http响应"></a>5.2.3Http响应</h3><ul>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">private</span>  </span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>响应体</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Accept:    <span class="comment">//告诉浏览器他所支持的数据类型</span></span><br><span class="line">Accept-Encoding: gzip, deflate, br <span class="comment">//GBK,UTF-8,GB2312,ISO-88591</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.9</span> <span class="comment">//中文</span></span><br><span class="line">Cache-Control: max-age=<span class="number">0</span> <span class="comment">//缓存控制</span></span><br><span class="line">Connection: keep-alive <span class="comment">//告诉浏览器请求结束是断开还是保持连接</span></span><br><span class="line">HOST:<span class="comment">//主机</span></span><br><span class="line">Refresh: <span class="comment">//告诉客户端多久刷新一次</span></span><br><span class="line">location: <span class="comment">//让网页重新定位</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-4响应状态码"><a href="#5-2-4响应状态码" class="headerlink" title="5.2.4响应状态码"></a>5.2.4响应状态码</h4><ul>
<li>200：请求响应成功</li>
<li>3xx：请求重定向（去新地方找）</li>
<li>4xx：找不到资源,资源不存在</li>
<li>5xx：服务器代码错，例如502网关错误</li>
</ul>
<h3 id="5-3HTTPS"><a href="#5-3HTTPS" class="headerlink" title="5.3HTTPS"></a>5.3HTTPS</h3><h2 id="6-Session-Cookie"><a href="#6-Session-Cookie" class="headerlink" title="6.Session/Cookie"></a>6.Session/Cookie</h2><h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1-SQL语句书写"><a href="#1-SQL语句书写" class="headerlink" title="1.SQL语句书写"></a>1.SQL语句书写</h3><h3 id="2-SQL语句优化"><a href="#2-SQL语句优化" class="headerlink" title="2.SQL语句优化"></a>2.SQL语句优化</h3><h3 id="3-事务以及隔离级别"><a href="#3-事务以及隔离级别" class="headerlink" title="3.事务以及隔离级别"></a>3.事务以及隔离级别</h3><h3 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h3><h3 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h3><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul>
<li>当要改传入的指针参数时，int &amp;*p，int * *p</li>
<li>malloc申请的连续地址可用data[i]的方式来访问，还要memset（）下</li>
<li>不能用l-&gt;next-&gt;next，无法确定l-&gt;next是否为空</li>
<li>带头节点：L-&gt;next == null;不带头节点：L == null</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Seqlist静态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[Maxsize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="comment">//Seqlist动态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>｛</span></span><br><span class="line"><span class="class">    <span class="title">ElemType</span> *<span class="title">data</span>；</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">maxsize</span>,<span class="title">length</span>;</span></span><br><span class="line">&#125;seqlist;</span><br><span class="line"><span class="comment">//L.data = (ElemType*)malloc(sizeof(ElemType) *Initsize);</span></span><br><span class="line"><span class="comment">//Linklist</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*Linklist；</span><br><span class="line"><span class="comment">//双链表DLinkList（*prior， *next）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;```</span><br><span class="line">## 判断链表是否有环，如果有找到环入口</span><br><span class="line"><span class="function">Lnode *<span class="title">FindLoopStart</span> <span class="params">(LNode *head)</span></span>&#123;</span><br><span class="line">    LNode fast=head,slow=head;</span><br><span class="line">    <span class="keyword">while</span> (slow!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast) <span class="keyword">break</span>;<span class="comment">//相遇</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(slowNULL||fast-&gt;nextNULL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode p1=head,p2=slow;</span><br><span class="line">    <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头到环入口距离为a，入口距相遇点距离为x，环长为r，相遇时fast绕过了n圈，则有2（a+x）=a+nr+x，即a=n*r-x，环内p2走n圈-x的距离时，p2刚好走到环入口Stack```</span></span><br></pre></td></tr></table></figure>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="易错点-1"><a href="#易错点-1" class="headerlink" title="易错点"></a>易错点</h3><ul>
<li>卡特兰数（Catalan）n个不同元素进栈，出栈元素不用排列的个数为1/（n+1）*C下2n上n</li>
<li>入栈判满，出栈判空，Last In First Out</li>
<li>入栈顺序与出栈顺序是反的；入队顺序与出队顺序是正的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Sqstack&#123;</span><br><span class="line">    ElemType data[Maxsize];</span><br><span class="line">    int top;</span><br><span class="line">&#125;Sqstack;</span><br><span class="line">//Top=-1</span><br><span class="line">typedef struct Linknode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct Linknode *next;</span><br><span class="line">&#125;*Listack;</span><br><span class="line">//表头操作，不带头的单链表```</span><br></pre></td></tr></table></figure>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="易错点-2"><a href="#易错点-2" class="headerlink" title="易错点"></a>易错点</h3><ul>
<li><p>队列选用不带头节点且有尾指针的循环单链表</p>
</li>
<li><p>循环对列队空：??Q.front == Q.rear??，队满??(Q.rear+1)%Maxsize == Q.front??，队长??(Q.rear+Maxsize-Q.front)%Maxsize??，入队??Q.rear=（Q.rear+1)%Maxsize rear指向插入位置??，出队??Q.front=(Q.front+1)%Maxsize front指向取出位置??，front指??头??，rear指??队尾下一个??</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[Maxsize];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//Q.front==null &amp;&amp; Q.rear == null时为空</span></span><br><span class="line"><span class="comment">//有头节点，且既有队头指针，又有队尾指针（队头指向头节点）</span></span><br><span class="line"><span class="comment">//初始化都指向头节点</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="易错点-3"><a href="#易错点-3" class="headerlink" title="易错点"></a>易错点</h3><ul>
<li>分支有向：双亲-&gt;孩子，兄弟间无路径，n个顶点+n-1条边</li>
<li>节点数等于所有结点的度数加1(一个节点度为0)</li>
<li>二叉树是有序树，子树有左右之分，就算只有一个节点也有左右之分，不同于度为的有序树（左右之分、至少0-至少3）</li>
<li>深度（上-&gt;下）、高度（下-&gt;上）</li>
<li>完全二叉树：按层排满再排下一层【判断是否是完全二叉树，队列找到NULL时，后面无节点】【n/2为最后一个分支节点】</li>
<li>非空二叉树：叶子结点数等于度为二的节点数加1，n个节点有n+1个空链域</li>
<li>二叉树的WPL为每个叶节点深度与权值之积的总和，只需计算叶结点！</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">T=（BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=data;</span><br><span class="line">T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//链式表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//树双亲表示法（只有唯一前驱，后继若干）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[Maxsize];<span class="comment">//线性表</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;PTree;</span><br><span class="line"><span class="comment">//树孩子表示法（孩子若干，连成一个链、类似于图的邻接表）一个数组带多条链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ElemType adjnode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ChildNode;</span><br><span class="line"><span class="keyword">typedef</span> Struct ParentNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    ChildNode *first;</span><br><span class="line">&#125;ParentNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ParentNode nodes[Maxsize];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;ChildTree;</span><br><span class="line"><span class="comment">//树孩子兄弟表示法（又称二叉树表示法，第一个孩子，下一个兄弟，可加parent域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibiling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br><span class="line"><span class="comment">//已知层次系列和每个节点的度，编写算法构造此树的孩子-兄弟链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxNodes 15</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createCSTree_Degree</span><span class="params">(CSTree &amp;T,DataType e[],<span class="keyword">int</span> degree[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    CSNode *pointer = <span class="keyword">new</span> CSNode[maxNodes];</span><br><span class="line">    <span class="keyword">int</span> i,j,d,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        pointer[i]-&gt;data = e[i];</span><br><span class="line">        pointer[i]-&gt;lchild=pointer[i]-&gt;rsibiling=<span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        d=degree[i];</span><br><span class="line">        <span class="keyword">if</span>(d)&#123;</span><br><span class="line">            k++;</span><br><span class="line">            pointer[i]-&gt;lchild=pointer[k];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=d;j++)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                pointer[k<span class="number">-1</span>]-&gt;rsibiling=pointer[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T=pointer[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span> [] pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 遍历（前、中、后、层次，递归、非递归），求高度（下-上），求层数（上-下）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=null)&#123;</span><br><span class="line">        visit (T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Void <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(P||!isEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span> (P)&#123;</span><br><span class="line">            <span class="comment">//先序的visit(p);</span></span><br><span class="line">            Push(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S,p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问左孩子时，栈中元素为其祖先节点；访问到右孩子时，除父节点外(pop掉了)，栈中元素为祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p=T;</span><br><span class="line">    r=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p||IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            push(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GetTop(S,p);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)&#123;</span><br><span class="line">                p=p-&gt;rchild;</span><br><span class="line">                push(S,p);</span><br><span class="line">                p=p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pop(S,p);</span><br><span class="line">                visit(p-&gt;data);</span><br><span class="line">                r=p;<span class="comment">//重要！！！上一个访问的节点</span></span><br><span class="line">                p=<span class="literal">NULL</span>;<span class="comment">//重要！跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层次遍历（链队列）</span></span><br><span class="line"><span class="comment">//层次遍历易于找到某节点的父节点</span></span><br><span class="line"><span class="keyword">void</span> LevelOrder（BiTree T)&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild)!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求高度（非递归层次遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Btdepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>（!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">-1</span>,rear=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>,level=<span class="number">0</span>;</span><br><span class="line">    BiTree Q[MaxSize];<span class="comment">//线形队列</span></span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;</span><br><span class="line">        p=Q[++front];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">            Q[++rear]=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">            Q[++rear]=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(front==last)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            last=rear;<span class="comment">//下一层最右端节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层数（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(BiTree T,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">            depth(T-&gt;lchild,++level);</span><br><span class="line">            level—-;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">            depth(T-&gt;rchild,++level);</span><br><span class="line">            level—-;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//level初值为0，此时level即为层数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;<span class="comment">//0为左孩子，1为前驱</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"><span class="comment">//左指前、右指后</span></span><br><span class="line"><span class="comment">//可以更方便地得到节点在遍历中的前驱和后继```</span></span><br><span class="line">- 二叉树中序线索化</span><br><span class="line">可以在线索链表上也添加一个头节点：左指根，右指中序尾，中序第一个和最后一个都指向头节点。（双向线索链表）</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTre &amp;pre)</span></span>&#123;<span class="comment">//线索指向上一层</span></span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        Inthread(p-&gt;rchild,pre);</span><br><span class="line"><span class="comment">//先序线索化(p的左指针被改过)</span></span><br><span class="line">    <span class="comment">//if(0==p-&gt;ltag) PreThread(p-&gt;lchild);</span></span><br><span class="line">    <span class="comment">//if(0==p-&gt;rtag) PreThread(p-&gt;rchild);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T,pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线索二叉树遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadNode *p = T;</span><br><span class="line">    <span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">            visit (p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        visit(p)</span><br><span class="line">        p=p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">getFirstNode</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadNode *p=T;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//返回最左下的节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadNode *<span class="title">getSuccessor</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadNode *p=T:</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(getFirstNode(p-&gt;lchild));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadNode *p =T;</span><br><span class="line">    <span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">        p=getSuccessor(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadNode *p=T;</span><br><span class="line">    ThreadNode *pre=null;</span><br><span class="line">    <span class="keyword">while</span>(null != p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pre!=p-&gt;lchild &amp;&amp; <span class="number">0</span>==p-&gt;ltag)<span class="comment">//往左下找</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(null!=p&amp;&amp;<span class="number">1</span>==p-&gt;rtag)&#123;<span class="comment">//开始访问</span></span><br><span class="line">            visit(p);</span><br><span class="line">            pre=p;</span><br><span class="line">            p=pre-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T == p)</span><br><span class="line">            visit(p);</span><br><span class="line">            p=null;</span><br><span class="line">        <span class="keyword">while</span>(null!=p&amp;&amp;p-&gt;rchild==pre)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p!=null&amp;&amp;p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找左，访问，定根，找根，找右</span></span><br><span class="line"><span class="comment">/*中序可找前可找后、先序可找后（找前需parent）、后序可找前（找后需parent，且注意根无后继）遍历需栈</span></span><br><span class="line"><span class="comment">先找到序列中的第一个节点，然后依次找节点后继，直至其后继为空,中序线索二叉树（左根右）找后继：若rtag=1，p=p-rchild（没有右子树）;否则遍历右子树中第一个访问的节点（右子树最左下的节点）。</span></span><br><span class="line"><span class="comment">先序线索二叉树（根左右）找后继：如果有左孩子，左孩子为其后继；如果没左孩子但有右孩子，则右孩子为其后继；如果是叶节点，则右链域直接指示其后继。</span></span><br><span class="line"><span class="comment">后续线索二叉树（左右根）找后继：1.若为根，则后继为空；2.若是双亲右孩子，或是双亲左孩子且双亲没有右子树，则其后继为双亲；3.若节点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树按后序遍历列出的第一个节点。*/</span></span><br><span class="line"><span class="comment">//先序遍历中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span> <span class="params">(ThreadTree)</span></span>&#123;</span><br><span class="line">    ThreadNode *p = T;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span>!=p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span>==p-&gt;lTag)&#123;</span><br><span class="line">            Visit(P);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>==p-&gt;rchild)&#123;</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;rchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>树与二叉树的转换：左孩子右兄弟，左指针指向第一个孩子，右指针指向第一个右兄弟</li>
<li>树的先根遍历、后根遍历的关系：<br>先根遍历（根左右） == 对应二叉树的先序序列 == 森林的先序遍历<br>后根遍历（左右根） == 对应二叉树的中序遍历 == 森林的中序遍历（先访问所有孩子，再访问根）【树和森林没有类似于二叉树的中序遍历】</li>
<li>森林的先序遍历、中序遍历<br>访问第一棵树根节点，先序第一棵树中根节点的子树森林，先序遍历其余树构成的森林<br>中序遍历森林第一棵树的根节点的子树森林，访问第一棵树根节点，中序遍历其余树构成的森林</li>
</ul>
<h3 id="BST（规则、递增序列、删除）"><a href="#BST（规则、递增序列、删除）" class="headerlink" title="BST（规则、递增序列、删除）"></a>BST（规则、递增序列、删除）</h3><ul>
<li>左子树&lt;根&lt;右子树，中序遍历为递增序列</li>
<li>删除：如果是叶节点直接删除，左子树为空用右子女；右子树为空用左子女；左右子树都不空在右子树上找中序第一个子女</li>
<li>查找失败：少对比了一次，没有对比空节点！！！</li>
<li>若是静态有序查找表：顺序表存储，二分查找实现操作；若是动态查找表：则应选择二叉排序树作为其逻辑结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KeyType predt=<span class="number">-32767</span><span class="comment">//全局变量，保存中序前驱的值</span></span><br><span class="line"><span class="comment">//中序遍历二叉排序树得到递增序列</span></span><br><span class="line"><span class="keyword">int</span> JudgeBST(BiTree bt)&#123;</span><br><span class="line">    <span class="keyword">int</span> b1,b2;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        b1=JudgeBST(bt-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(b1==<span class="number">0</span>||predt&gt;=bt-&gt;data)<span class="comment">//前一次比较失败或本次比较失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        predt=bt-&gt;data;</span><br><span class="line">        b2=JudgeBST(bt-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> b2;<span class="comment">//左面和本次已经比较完了，如果都成功，则只需要返回右面的比较结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AVL（规则、插入）"><a href="#AVL（规则、插入）" class="headerlink" title="AVL（规则、插入）"></a>AVL（规则、插入）</h3><ul>
<li>左右子树高度差绝对值&lt;=1</li>
<li>调整最小不平衡子树：<br>LL：右单旋；RR：左单旋；<br>LR：先左后右双旋；RL：先右后左双旋</li>
<li>深度为h的平衡树含有最少节点数=h-1层+h-2层+1（no=0、n1=1、n2=2）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JudgeAVL</span><span class="params">(BiTree bt,<span class="keyword">int</span> &amp;balance,<span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl=<span class="number">0</span>,br=<span class="number">0</span>,hl=<span class="number">0</span>,hr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        h=<span class="number">0</span>;</span><br><span class="line">        balance=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchildNULL&amp;&amp;bt-&gt;rchildNULL)&#123;</span><br><span class="line">        h=<span class="number">1</span>;</span><br><span class="line">        balance=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        JudgeAVL(bt-&gt;lchild,bl,hl);</span><br><span class="line">        JudgeAVL(bt-&gt;rchild,br,hr);</span><br><span class="line">        h=(hl&gt;hr?hl:hr)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(hl-hr)&lt;<span class="number">2</span>)<span class="comment">//本层平衡</span></span><br><span class="line">            balance=bl&amp;&amp;br;<span class="comment">//子树平衡</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            balance=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈夫曼树（规则、建立、编码）"><a href="#哈夫曼树（规则、建立、编码）" class="headerlink" title="哈夫曼树（规则、建立、编码）"></a>哈夫曼树（规则、建立、编码）</h3><ul>
<li>WPL（带权路径长度）最小，又称最优二叉排序树</li>
<li>找俩小成兄弟</li>
<li>左0右1</li>
<li>n个节点的哈夫曼树有n-1条分支</li>
</ul>
<h3 id="最佳二叉排序树"><a href="#最佳二叉排序树" class="headerlink" title="最佳二叉排序树"></a>最佳二叉排序树</h3><ul>
<li>等概率时，从小到大排列，用折半查找的判定树构造方法构造二叉排序树（高度最小）</li>
</ul>
<h3 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h3><ul>
<li>中缀表达式树：除根节点和操作数外，采取中序遍历，遍历左子树前加左括号，遍历右子树后加右括号</li>
</ul>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>完全图：有向图边数0～n(n-1)、无向图边数0～n(n-1)/2（任意两个顶点之间都存在弧）</li>
<li>子图：顶点和边的子集，生成子图：顶点都在的子图</li>
<li>连通：无向图两个节点间有路径；强连通：有向图两个节点间有双向路径（！极大连通子图=连通分量；极大强连通子图=强连通分量）非连通图最多(n-1)(n-2)/2(C排列组合公式完全图去掉n-1条边)</li>
<li>一个单独的顶点也是一个强连通分量</li>
<li>生成树：包含全部顶点的一个极小连通子图，含有n-1条边（类似树，少一个不连通，多一个有回路）</li>
<li>距离：两点间最短路径</li>
<li>无向图某顶点的度为依附顶点的边的个数；有向图某顶点的度为入度和出度的和</li>
<li>A^n对应i行j列数值为i到j路径长度为n的路径数目</li>
<li>7个顶点无向图边数为16时必连通，n个节点连通无向图至少n-1条边，强连通有向图至少n条边</li>
<li>判断是否是一棵树：连通：能否遍历全部顶点；是一棵树：无回路的的连通图或有n-1条边的连通图（一次遍历就能访问到n个顶点和n-1条边，无向图为2*（n-1）条边）</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];</span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//无权图用1/0，带权图用∞/权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表法（结构体非指针）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//邻接表弧头节点(指谁存谁)；逆邻接表弧尾节点（谁指的存谁）             </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//InfoType info;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *first;</span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//是一个数组，用int表示点</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十字链表法</span></span><br><span class="line"><span class="comment">//横看出度，竖看入度；先写信息，后连指针；左三右四。</span></span><br><span class="line"><span class="comment">//顶点节点：</span></span><br><span class="line"><span class="comment">//data firstin firstout</span></span><br><span class="line"><span class="comment">//入弧     出弧</span></span><br><span class="line"><span class="comment">//弧节点</span></span><br><span class="line"><span class="comment">//tailvex headvex hlink tlink info</span></span><br><span class="line"><span class="comment">//尾顶点   头顶点   同头弧 同尾弧</span></span><br><span class="line"><span class="comment">//为了方便找有向图的入度和出度，弧头相同的的弧在一个链表上；弧尾相同的弧也在一个链表上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接多重表</span></span><br><span class="line"><span class="comment">//一次节点一次边，两个指针两个域，从顶点开始，相同数字连成线。</span></span><br><span class="line"><span class="comment">//mark ivex ilink jvex jlink info</span></span><br><span class="line"><span class="comment">//data firstedge</span></span><br><span class="line"><span class="comment">//无向图中所有依附与同一节点的边串联在同一链表中，每个边节点同时在两个链表中，</span></span><br><span class="line"><span class="comment">//与邻接表比存了一次</span></span><br><span class="line"><span class="comment">//从根开始找相同的数连成链表</span></span><br></pre></td></tr></table></figure>

<h3 id="BFS（类似树层次遍历），无权图求单源最短路径"><a href="#BFS（类似树层次遍历），无权图求单源最短路径" class="headerlink" title="BFS（类似树层次遍历），无权图求单源最短路径"></a>BFS（类似树层次遍历），无权图求单源最短路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            BFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=TRUE;</span><br><span class="line">    Enqueue(Q,v);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            visit(w);</span><br><span class="line">            visited[w]=TRUE;</span><br><span class="line">            EnQueue(Q,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSMinDistance</span><span class="params">(Graph G,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="comment">//d[i]从u到i节点最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        d[i] = ∞;</span><br><span class="line">    visited[u]=TRUE;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    Enqueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,u);</span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visited[w]=TRUE;</span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS（递归、非递归）（类似树先序遍历）【判断是否有环】"><a href="#DFS（递归、非递归）（类似树先序遍历）【判断是否有环】" class="headerlink" title="DFS（递归、非递归）（类似树先序遍历）【判断是否有环】"></a>DFS（递归、非递归）（类似树先序遍历）【判断是否有环】</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=FALSE;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=TRUE;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph g,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;g.vexnum;i++)</span><br><span class="line">        visited[i]=FALSE;</span><br><span class="line">    Push(S,v);</span><br><span class="line">    visited[v]=TRUE;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S))&#123;</span><br><span class="line">        k=Pop(S);</span><br><span class="line">        visit(k);<span class="comment">//先访问，后将子节点入栈</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,k);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,k,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                Push(S,w);</span><br><span class="line">                visited[w]=<span class="literal">true</span>;<span class="comment">//防止再次入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="输出Vi到Vj的所有简单路径"><a href="#输出Vi到Vj的所有简单路径" class="headerlink" title="输出Vi到Vj的所有简单路径"></a>输出Vi到Vj的所有简单路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(Graph *G,<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> path[],<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w,i;</span><br><span class="line">    ArcNode *P;</span><br><span class="line">    d++;</span><br><span class="line">    path[d]=u;</span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u==v)</span><br><span class="line">        print(path[]);</span><br><span class="line">    P=G-&gt;adjlist[u].firstarc;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        w=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(visited[w]==<span class="number">0</span>)</span><br><span class="line">            FindPath(G,w,v,path,d);</span><br><span class="line">        p=p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u]=<span class="number">0</span>;<span class="comment">//恢复环境，使该节点可重新使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小生成树（PK算法）"><a href="#最小生成树（PK算法）" class="headerlink" title="最小生成树（PK算法）"></a>最小生成树（PK算法）</h3><ul>
<li>带权连通图的任意一个环中所包含的边权值均不相等时，其最小生成树是唯一的</li>
<li>Prim：找点，适合求解边稠密的图</li>
<li>Kruskal：找边，适合求解边稀疏而顶点较多的图，采用堆来存放边的集合</li>
</ul>
<h3 id="最短路径（DF算法）"><a href="#最短路径（DF算法）" class="headerlink" title="最短路径（DF算法）"></a>最短路径（DF算法）</h3><ul>
<li>Dijkstra：<br>求有向图某一个顶点到其余各顶点的最短路径，dist[]源点到各顶点最短路径长度 path[]v到当前节点的最短路径的前驱节点，首先初始化，算距离改dist[],找最小改path[],加和比较继续迭代</li>
<li>Floyd：<br>求有向图每对顶点之间最短路径，用边矩阵作为A⁻¹进行迭代，每次加进来一个顶点，并遍历矩阵进行修改(A[i][j]&gt;A[i][k]+A[k][j])，最后得到任意两节点间最短路径矩阵</li>
</ul>
<h3 id="AOV网：拓扑排序"><a href="#AOV网：拓扑排序" class="headerlink" title="AOV网：拓扑排序"></a>AOV网：拓扑排序</h3><ul>
<li>DAG图（有向无环图）</li>
<li>可判断有向图是否有回路</li>
<li>邻接矩阵是三角矩阵，则存在拓扑序列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;<span class="comment">//不用visited[]</span></span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Push(S,i);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">        Pop(S,i);</span><br><span class="line">        print[count++]=i;</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            v=p-&gt;adjvex;<span class="comment">//由边找到点</span></span><br><span class="line">            <span class="keyword">if</span>(!(—-indegree[v]))</span><br><span class="line">                Push(S,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用DFS实现无环图拓扑排序！</span></span><br><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v]=FALSE;</span><br><span class="line">    time = <span class="number">0</span><span class="comment">//有向无环图拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=TRUE;</span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">    &#125;</span><br><span class="line">    time = time+<span class="number">1</span>;</span><br><span class="line">    finishTime[v]=time;</span><br><span class="line">    <span class="comment">//时间从大到小排序即可得到拓扑排序</span></span><br><span class="line">    <span class="comment">//从下往上一层层加时间，最上面的时间最长</span></span><br><span class="line">    <span class="comment">//子孙先结束，祖先后结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆拓扑排序</span></span><br><span class="line"><span class="comment">//从AOV网中选择一个没有后继的顶点并输出</span></span><br><span class="line"><span class="comment">//从网中删除该顶点和所有以它为终点的有向边</span></span><br><span class="line"><span class="comment">//重复以上两点，直到为空```</span></span><br></pre></td></tr></table></figure>

<h3 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h3><ul>
<li>关键路径（最大路径长度）<br>去大回小<br>拓扑排序+逆拓扑排序=关键路径<br>完成工程的最短时间=关键路径长度=最大路径长度</li>
<li>顶点表示事件，有向边表示活动</li>
<li>只有某节点所代表的事情发生后从该顶点出发的各有向边所代表的活动才能开始；只有进入某顶点的有向边所代表的活动都结束时，该顶点所代表的事件才能发生。Ve（k）、Vl（k）、e（i）、l（i）</li>
<li>对于有多条关键路径的网，只有加快包含在所有关键路径上的关键活动才能达到缩短工期的目的。</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1-算法概述"><a href="#1-算法概述" class="headerlink" title="1.算法概述"></a>1.算法概述</h2><ul>
<li>数据结构：逻辑结构+存储结构+数据的运算</li>
<li>时间复杂度：不看低阶、不看系数、加法取大、乘法取积、最坏+平均+最好</li>
<li>O(1)&lt;O(log2 n)&lt;O(n)&lt;O(nlog2 n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</li>
<li>空间复杂度：循环、递归调用栈、辅存</li>
</ul>
<h2 id="2-算法思想"><a href="#2-算法思想" class="headerlink" title="2.算法思想"></a>2.算法思想</h2><h3 id="2-1贪心算法"><a href="#2-1贪心算法" class="headerlink" title="2.1贪心算法"></a>2.1贪心算法</h3><h3 id="2-2分治算法"><a href="#2-2分治算法" class="headerlink" title="2.2分治算法"></a>2.2分治算法</h3><h3 id="2-3动态规划"><a href="#2-3动态规划" class="headerlink" title="2.3动态规划"></a>2.3动态规划</h3><h3 id="2-4回溯算法"><a href="#2-4回溯算法" class="headerlink" title="2.4回溯算法"></a>2.4回溯算法</h3><h3 id="2-5枚举算法"><a href="#2-5枚举算法" class="headerlink" title="2.5枚举算法"></a>2.5枚举算法</h3><h2 id="3-Search（null不算比较次数）"><a href="#3-Search（null不算比较次数）" class="headerlink" title="3.Search（null不算比较次数）"></a>3.Search（null不算比较次数）</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ul>
<li>哨兵：避免很多不必要的判断依据，从而提高程序效率</li>
<li>循环的时候把数组第一个元素设为key，并从后往前找，从而不用判断数组是否越界，因为循环一定会跳出来</li>
<li>判定树：圆形代表存在的元素，矩形代表不存在的范围，分支为 &lt; 和 &gt;</li>
<li>查找失败：查到的是虚构的空节点，查找长度为上一个节点所在层数</li>
</ul>
<h3 id="折半查找（判定树右多一）"><a href="#折半查找（判定树右多一）" class="headerlink" title="折半查找（判定树右多一）"></a>折半查找（判定树右多一）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判定树是一棵平衡二叉树</span></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearchRec</span><span class="params">(SSTable ST,ElemType key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&gt;ST.elem[mid])</span><br><span class="line">            <span class="keyword">return</span>(Search(ST,key,mid+<span class="number">1</span>,high));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;ST.elem[mid])</span><br><span class="line">            <span class="keyword">return</span>(Search(ST,key,low,mid<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B+树"></a>B树、B+树</h3><ul>
<li>定义：m叉树m个分支m-1个关键字；若根不是终端则至少两颗子树；除根节点外所有非叶至少m/2上取整颗子树</li>
<li>B树不支持顺序查找，B+树支持顺序查找</li>
<li>B树删除：兄弟够借（&gt;=2）就左旋借一圈；左右兄弟都不够借，父节点下来一个跟兄弟合并</li>
</ul>
<h3 id="Hash查找"><a href="#Hash查找" class="headerlink" title="Hash查找"></a>Hash查找</h3><ul>
<li>开放地址法（探测到表尾从表头起）&amp;拉链法</li>
<li>线性探测：+K；= 线形探测再散列</li>
<li>二次探测：冲突时按+1、-1、+4、-4、+9、-9</li>
<li>如果m=13，ASL成功：除表中数据个数；ASL失败：除能映射到的地址个数！！！</li>
<li>开放地址法删除：只做标记，不删除</li>
<li>装填因子：表中记录数/散列表长度</li>
</ul>
<h2 id="4-Sort"><a href="#4-Sort" class="headerlink" title="4.Sort"></a>4.Sort</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">            A[<span class="number">0</span>]=A[i<span class="number">-1</span>];<span class="comment">//哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];—-j)</span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//后移</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><ul>
<li>用折半查找找插入位置，再统一移动元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];</span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;—-j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul>
<li>先对各子表进行直接插入排序，当整个表已呈基本有序的时候，对全体记录进行一次插入排序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(dk=n/<span class="number">2</span>;dk&gt;=<span class="number">1</span>;dk=dk/<span class="number">2</span>)<span class="comment">//步长</span></span><br><span class="line">        <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;<span class="comment">//交换</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];<span class="comment">//哨兵</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=dk)</span><br><span class="line">                    A[j+dk]=A[j];<span class="comment">//大的后移</span></span><br><span class="line">                A[j+dk]=A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从第一个有前驱增量元素的节点开始，依次向前检查交换</span></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序（flag标志）"><a href="#冒泡排序（flag标志）" class="headerlink" title="冒泡排序（flag标志）"></a>冒泡排序（flag标志）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//n-1趟，前i个有序</span></span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j—-)<span class="comment">//从后往前冒泡到i</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序（平均性能最优）"><a href="#快速排序（平均性能最优）" class="headerlink" title="快速排序（平均性能最优）"></a>快速排序（平均性能最优）</h3><ul>
<li>非递归要用到一个栈（或队列）在处理一个待排序区间时，保存另一个待排序区间的上界和下界。</li>
<li>一个pivot，一趟快排</li>
<li>pivot等分最快，有序或逆序最慢O（n²）</li>
<li>一趟快排：对尚未确定最终位置的元素进行一次处理（全处理一遍为一趟）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">    <span class="comment">//Partition()划分操作</span></span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition(A, low, high);<span class="comment">//一次快排</span></span><br><span class="line">    QuickSort(A, low, pivospos<span class="number">-1</span>);<span class="comment">//排左</span></span><br><span class="line">    QuickSort(A, pivotpos+<span class="number">1</span>, high);<span class="comment">//排右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从前往后找不符合的换到后面，从后往前找换</span></span><br><span class="line">到前面</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)</span><br><span class="line">            —-high;</span><br><span class="line">        A[low]=A[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)</span><br><span class="line">            ++low;</span><br><span class="line">        A[high]=A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;<span class="comment">//low的位置是pivot的位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从前往后找符合的换到前面</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partion2</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    ElemType pivot=A[low];</span><br><span class="line">    <span class="keyword">int</span> i=low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=low+<span class="number">1</span>;j&lt;=high;j++)</span><br><span class="line">        <span class="keyword">if</span>(A[j]&lt;pivot)</span><br><span class="line">            swap(A[++i],A[j]);</span><br><span class="line">        swap(A[i],A[low]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>不稳定，前面换完后面不换了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        min=i;</span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(A[j]&lt;A[min]) </span><br><span class="line">            min=j;</span><br><span class="line">    <span class="keyword">if</span>(min!=i) </span><br><span class="line">        swap(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>大顶堆：根大于左右孩子，用于排升序</li>
<li>小顶堆：根小于左右孩子，用于排降序</li>
<li>先按层次序列建树，再从下往上调整建堆</li>
<li>建堆：先按层次遍历建树，在从最后一个父节点从下往上修改建堆</li>
<li>找前100个最大值，建小顶堆，小于堆顶则舍弃</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i—-)<span class="comment">//最后一个非叶节点</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从k为根的子树开始调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[],<span class="keyword">int</span> k;<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];<span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="comment">//往下找最大的来换</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span> * k;i&lt;=len;i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">            i++;<span class="comment">//换成右子树</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i]) </span><br><span class="line">            berak;<span class="comment">//下面都是小的了</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k]=A[i];<span class="comment">//将子树大的往上提</span></span><br><span class="line">            k=i;<span class="comment">//开始改子树，向下找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];<span class="comment">//被筛选的节点值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);</span><br><span class="line">    <span class="keyword">for</span>(i=len;i&gt;<span class="number">1</span>;i—-)&#123;</span><br><span class="line">        Swap(A[i],A[<span class="number">1</span>]);<span class="comment">//最大的放到数组尾</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//调整剩余i-1个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>需要一个数组作为辅助空间，先把数据复制到新数组中，从中间分成两个子数组，再比较插回原数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ElemType *B=(ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) *<span class="keyword">sizeof</span>(ElemType));<span class="comment">//辅助数组B</span></span><br><span class="line"><span class="comment">//low~mid,mid+1~high各自有序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k];<span class="comment">//复制数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;<span class="comment">//比较后查回</span></span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])</span><br><span class="line">            A[k]=B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写回剩余数据</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">         MergeSort(A,low,mid);<span class="comment">//从一部分数组开始</span></span><br><span class="line">         MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">         Merge(A,low,mid,high);<span class="comment">//到全部的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul>
<li>最高为优先法（MSD）：按关键字位权重递减依次逐层划分</li>
<li>最低位优先法（LSD）：按关键字位权重递增依次逐层划分，排完一次不直接放回，在内部递归进行</li>
</ul>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><ul>
<li>计数排序</li>
<li>技术排序</li>
<li>桶排序</li>
</ul>
<h2 id="5-搜索"><a href="#5-搜索" class="headerlink" title="5.搜索"></a>5.搜索</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h3 id="A-启发式搜索"><a href="#A-启发式搜索" class="headerlink" title="A*启发式搜索"></a>A*启发式搜索</h3><h2 id="6-字符串匹配"><a href="#6-字符串匹配" class="headerlink" title="6.字符串匹配"></a>6.字符串匹配</h2><p>朴素</p>
<p>Robin-Karp</p>
<p>Boyer-Moore（高效）</p>
<p>KMP</p>
<p>Trie树</p>
<p>AC自动机</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h2><h2 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2.设计原则"></a>2.设计原则</h2><h3 id="2-1SOLID原则"><a href="#2-1SOLID原则" class="headerlink" title="2.1SOLID原则"></a>2.1SOLID原则</h3><h4 id="2-1-1SRP单一职责原则"><a href="#2-1-1SRP单一职责原则" class="headerlink" title="2.1.1SRP单一职责原则"></a>2.1.1SRP单一职责原则</h4><h4 id="2-1-2OCP开闭原则"><a href="#2-1-2OCP开闭原则" class="headerlink" title="2.1.2OCP开闭原则"></a>2.1.2OCP开闭原则</h4><h4 id="2-1-3LSP里式替换原则"><a href="#2-1-3LSP里式替换原则" class="headerlink" title="2.1.3LSP里式替换原则"></a>2.1.3LSP里式替换原则</h4><h4 id="2-1-4ISP接口隔离原则"><a href="#2-1-4ISP接口隔离原则" class="headerlink" title="2.1.4ISP接口隔离原则"></a>2.1.4ISP接口隔离原则</h4><h4 id="2-1-5DIP依赖倒置原则"><a href="#2-1-5DIP依赖倒置原则" class="headerlink" title="2.1.5DIP依赖倒置原则"></a>2.1.5DIP依赖倒置原则</h4><h2 id="2-2其它原则"><a href="#2-2其它原则" class="headerlink" title="2.2其它原则"></a>2.2其它原则</h2><h3 id="2-2-1DRY原则"><a href="#2-2-1DRY原则" class="headerlink" title="2.2.1DRY原则"></a>2.2.1DRY原则</h3><h3 id="2-2-2KISS原则"><a href="#2-2-2KISS原则" class="headerlink" title="2.2.2KISS原则"></a>2.2.2KISS原则</h3><h3 id="2-2-3YAGNI原则"><a href="#2-2-3YAGNI原则" class="headerlink" title="2.2.3YAGNI原则"></a>2.2.3YAGNI原则</h3><h3 id="2-2-4LOD原则"><a href="#2-2-4LOD原则" class="headerlink" title="2.2.4LOD原则"></a>2.2.4LOD原则</h3><h2 id="3-编程规范"><a href="#3-编程规范" class="headerlink" title="3.编程规范"></a>3.编程规范</h2><h2 id="4-代码重构"><a href="#4-代码重构" class="headerlink" title="4.代码重构"></a>4.代码重构</h2><h2 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5.设计模式"></a>5.设计模式</h2><h3 id="5-1创建型"><a href="#5-1创建型" class="headerlink" title="5.1创建型"></a>5.1创建型</h3><h4 id="5-1-1单例模式"><a href="#5-1-1单例模式" class="headerlink" title="5.1.1单例模式"></a>5.1.1单例模式</h4><h4 id="5-1-2工厂模式"><a href="#5-1-2工厂模式" class="headerlink" title="5.1.2工厂模式"></a>5.1.2工厂模式</h4><h4 id="5-1-3建造者模式（工厂方法和抽象工厂）"><a href="#5-1-3建造者模式（工厂方法和抽象工厂）" class="headerlink" title="5.1.3建造者模式（工厂方法和抽象工厂）"></a>5.1.3建造者模式（工厂方法和抽象工厂）</h4><h4 id="5-1-4原型模式"><a href="#5-1-4原型模式" class="headerlink" title="5.1.4原型模式"></a>5.1.4原型模式</h4><h3 id="5-2结构型"><a href="#5-2结构型" class="headerlink" title="5.2结构型"></a>5.2结构型</h3><h3 id="5-2-1代理模式"><a href="#5-2-1代理模式" class="headerlink" title="5.2.1代理模式"></a>5.2.1代理模式</h3><h3 id="5-2-2桥接模式"><a href="#5-2-2桥接模式" class="headerlink" title="5.2.2桥接模式"></a>5.2.2桥接模式</h3><h3 id="5-2-3装饰者模式"><a href="#5-2-3装饰者模式" class="headerlink" title="5.2.3装饰者模式"></a>5.2.3装饰者模式</h3><h3 id="5-2-4适配器模式"><a href="#5-2-4适配器模式" class="headerlink" title="5.2.4适配器模式"></a>5.2.4适配器模式</h3><h3 id="5-2-5门面模式"><a href="#5-2-5门面模式" class="headerlink" title="5.2.5门面模式"></a>5.2.5门面模式</h3><h3 id="5-2-6组合模式"><a href="#5-2-6组合模式" class="headerlink" title="5.2.6组合模式"></a>5.2.6组合模式</h3><h3 id="5-2-7组合模式"><a href="#5-2-7组合模式" class="headerlink" title="5.2.7组合模式"></a>5.2.7组合模式</h3><h3 id="5-2-8享元模式"><a href="#5-2-8享元模式" class="headerlink" title="5.2.8享元模式"></a>5.2.8享元模式</h3><h3 id="5-3行为型"><a href="#5-3行为型" class="headerlink" title="5.3行为型"></a>5.3行为型</h3><h3 id="5-3-1观察者模式"><a href="#5-3-1观察者模式" class="headerlink" title="5.3.1观察者模式"></a>5.3.1观察者模式</h3><h3 id="5-3-2模板模式"><a href="#5-3-2模板模式" class="headerlink" title="5.3.2模板模式"></a>5.3.2模板模式</h3><h3 id="5-3-3策略模式"><a href="#5-3-3策略模式" class="headerlink" title="5.3.3策略模式"></a>5.3.3策略模式</h3><h3 id="5-3-4职责链模式"><a href="#5-3-4职责链模式" class="headerlink" title="5.3.4职责链模式"></a>5.3.4职责链模式</h3><h3 id="5-3-5迭代器模式"><a href="#5-3-5迭代器模式" class="headerlink" title="5.3.5迭代器模式"></a>5.3.5迭代器模式</h3><h3 id="5-3-6状态模式"><a href="#5-3-6状态模式" class="headerlink" title="5.3.6状态模式"></a>5.3.6状态模式</h3><h3 id="5-3-7访问者模式"><a href="#5-3-7访问者模式" class="headerlink" title="5.3.7访问者模式"></a>5.3.7访问者模式</h3><h3 id="5-3-8备忘录模式"><a href="#5-3-8备忘录模式" class="headerlink" title="5.3.8备忘录模式"></a>5.3.8备忘录模式</h3><h3 id="5-3-9命令模式"><a href="#5-3-9命令模式" class="headerlink" title="5.3.9命令模式"></a>5.3.9命令模式</h3><h3 id="5-3-10解释器模式"><a href="#5-3-10解释器模式" class="headerlink" title="5.3.10解释器模式"></a>5.3.10解释器模式</h3><h3 id="5-3-11中介模式"><a href="#5-3-11中介模式" class="headerlink" title="5.3.11中介模式"></a>5.3.11中介模式</h3><h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><ol>
<li>Java核心技术卷一</li>
<li>Java核心技术卷二</li>
<li>Spring实战</li>
<li>SpringBoot实战</li>
<li>Effective Java</li>
<li>Java并发编程实战</li>
<li>Java性能权威指南</li>
<li>设计模式</li>
<li>代码大全</li>
</ol>
<ol>
<li><p>鸟哥的linux私房菜</p>
</li>
<li><p>现代操作系统</p>
</li>
<li><p>计算机网络自顶向下</p>
</li>
<li><p>计算机程序的构造和解释</p>
</li>
<li><p>编译原理</p>
</li>
<li><p>算法导论</p>
</li>
<li><p>深入理解计算机系统</p>
</li>
<li><p>UNIX高级环境编程</p>
</li>
<li><p>Unix网络编程第一卷</p>
</li>
<li><p>Unix网络编程第二卷</p>
</li>
<li><p>TCP/IP详解卷1</p>
</li>
</ol>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Dajunnnnnn | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/Dajunnnnnn.github.io/libs/jquery.min.js"></script>


<script src="/Dajunnnnnn.github.io/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/Dajunnnnnn.github.io/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
